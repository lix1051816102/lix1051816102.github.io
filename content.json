[{"title":"《Head First设计模式》读书笔记四","date":"2020-07-18T16:00:00.000Z","path":"2020/07/19/1-010/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！ 观察者模式（Observer Pattern）和模版方法模式（Template Method Pattern）一、观察者模式 定义：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。优点：观察者模式定义了一系列对象之间的一对多关系，当一个对象改变状态，其他依赖者会收到通知。 对应的设计原则： 为了交互对象之间的松耦合设计而努力 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你 1.1、示例程序类图 1.2、模式类图 二、模版方法模式 定义：模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。优点：模版方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。 对应的设计原则： 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你 2.1、示例程序类图 2.2、模式类图","raw":"---\ntitle: 《Head First设计模式》读书笔记四\n\ndate: 2020-07-19\n\ntoc: true\n\ncategories: \n- 后端\n\ntags: \n- 《Head First设计模式》\n- 读书笔记\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---\n\n观察者模式（Observer Pattern）和模版方法模式（Template Method Pattern）\n=====\n\n一、观察者模式\n-----\n> 定义：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。\n> 优点：观察者模式定义了一系列对象之间的一对多关系，当一个对象改变状态，其他依赖者会收到通知。\n-----\n> 对应的设计原则：\n* 为了交互对象之间的松耦合设计而努力\n* 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你\n\n1.1、示例程序类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_010_20200719/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n1.2、模式类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_010_20200719/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n二、模版方法模式\n-----\n> 定义：模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。\n> 优点：模版方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。\n-----\n> 对应的设计原则：\n* 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你\n\n2.1、示例程序类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_010_20200719/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n2.2、模式类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_010_20200719/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n<h1 id=\"观察者模式（Observer-Pattern）和模版方法模式（Template-Method-Pattern）\"><a href=\"#观察者模式（Observer-Pattern）和模版方法模式（Template-Method-Pattern）\" class=\"headerlink\" title=\"观察者模式（Observer Pattern）和模版方法模式（Template Method Pattern）\"></a>观察者模式（Observer Pattern）和模版方法模式（Template Method Pattern）</h1><h2 id=\"一、观察者模式\"><a href=\"#一、观察者模式\" class=\"headerlink\" title=\"一、观察者模式\"></a>一、观察者模式</h2><blockquote>\n<p>定义：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。<br>优点：观察者模式定义了一系列对象之间的一对多关系，当一个对象改变状态，其他依赖者会收到通知。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对应的设计原则：</p>\n<ul>\n<li>为了交互对象之间的松耦合设计而努力</li>\n<li>好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你</li>\n</ul>\n</blockquote>\n<h2 id=\"1-1、示例程序类图\"><a href=\"#1-1、示例程序类图\" class=\"headerlink\" title=\"1.1、示例程序类图\"></a>1.1、示例程序类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_010_20200719/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"1-2、模式类图\"><a href=\"#1-2、模式类图\" class=\"headerlink\" title=\"1.2、模式类图\"></a>1.2、模式类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_010_20200719/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"二、模版方法模式\"><a href=\"#二、模版方法模式\" class=\"headerlink\" title=\"二、模版方法模式\"></a>二、模版方法模式</h2><blockquote>\n<p>定义：模版方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。<br>优点：模版方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对应的设计原则：</p>\n<ul>\n<li>好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你</li>\n</ul>\n</blockquote>\n<h2 id=\"2-1、示例程序类图\"><a href=\"#2-1、示例程序类图\" class=\"headerlink\" title=\"2.1、示例程序类图\"></a>2.1、示例程序类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_010_20200719/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"2-2、模式类图\"><a href=\"#2-2、模式类图\" class=\"headerlink\" title=\"2.2、模式类图\"></a>2.2、模式类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_010_20200719/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>","slug":"1-010","updated":"2020-07-20T13:31:46.731Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2020/07/19/1-010/","excerpt":"","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.elfli.cn/categories/后端/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.elfli.cn/tags/读书笔记/"},{"name":"《Head First设计模式》","slug":"《Head-First设计模式》","permalink":"https://blog.elfli.cn/tags/《Head-First设计模式》/"}]},{"title":"《Head First设计模式》读书笔记三","date":"2020-07-17T16:00:00.000Z","path":"2020/07/18/1-009/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！ 装饰者模式（Decorator Pattern）和代理模式（Proxy Pattern）一、装饰者模式 定义：装饰者模式动态地将责任附加在对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。优点：装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。 对应的设计原则： 开闭原则：类应该对扩展开放，对修改关闭 1.1、示例程序类图 1.2、模式类图 二、代理模式 定义：代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。优点：使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。 对应的设计原则： 开闭原则：类应该对扩展开放，对修改关闭 2.1、静态代理示例程序类图 2.2、静态代理模式类图 2.3、动态代理示例程序类图 2.4、动态代理模式类图","raw":"---\ntitle: 《Head First设计模式》读书笔记三\n\ndate: 2020-07-18\n\ntoc: true\n\ncategories: \n- 后端\n\ntags: \n- 《Head First设计模式》\n- 读书笔记\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---\n\n装饰者模式（Decorator Pattern）和代理模式（Proxy Pattern）\n=====\n\n一、装饰者模式\n-----\n> 定义：装饰者模式动态地将责任附加在对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。\n> 优点：装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。\n-----\n> 对应的设计原则：\n* 开闭原则：类应该对扩展开放，对修改关闭\n\n1.1、示例程序类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n1.2、模式类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n二、代理模式\n-----\n> 定义：代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。\n> 优点：使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。\n-----\n> 对应的设计原则：\n* 开闭原则：类应该对扩展开放，对修改关闭\n\n2.1、静态代理示例程序类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n2.2、静态代理模式类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>\n\n2.3、动态代理示例程序类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/05.jpg\" alt=\"图5\" width=\"80%\" height=\"80%\"></div>\n\n2.4、动态代理模式类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/06.jpg\" alt=\"图6\" width=\"80%\" height=\"80%\"></div>\n","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n<h1 id=\"装饰者模式（Decorator-Pattern）和代理模式（Proxy-Pattern）\"><a href=\"#装饰者模式（Decorator-Pattern）和代理模式（Proxy-Pattern）\" class=\"headerlink\" title=\"装饰者模式（Decorator Pattern）和代理模式（Proxy Pattern）\"></a>装饰者模式（Decorator Pattern）和代理模式（Proxy Pattern）</h1><h2 id=\"一、装饰者模式\"><a href=\"#一、装饰者模式\" class=\"headerlink\" title=\"一、装饰者模式\"></a>一、装饰者模式</h2><blockquote>\n<p>定义：装饰者模式动态地将责任附加在对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。<br>优点：装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对应的设计原则：</p>\n<ul>\n<li>开闭原则：类应该对扩展开放，对修改关闭</li>\n</ul>\n</blockquote>\n<h2 id=\"1-1、示例程序类图\"><a href=\"#1-1、示例程序类图\" class=\"headerlink\" title=\"1.1、示例程序类图\"></a>1.1、示例程序类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"1-2、模式类图\"><a href=\"#1-2、模式类图\" class=\"headerlink\" title=\"1.2、模式类图\"></a>1.2、模式类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"二、代理模式\"><a href=\"#二、代理模式\" class=\"headerlink\" title=\"二、代理模式\"></a>二、代理模式</h2><blockquote>\n<p>定义：代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。<br>优点：使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对应的设计原则：</p>\n<ul>\n<li>开闭原则：类应该对扩展开放，对修改关闭</li>\n</ul>\n</blockquote>\n<h2 id=\"2-1、静态代理示例程序类图\"><a href=\"#2-1、静态代理示例程序类图\" class=\"headerlink\" title=\"2.1、静态代理示例程序类图\"></a>2.1、静态代理示例程序类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"2-2、静态代理模式类图\"><a href=\"#2-2、静态代理模式类图\" class=\"headerlink\" title=\"2.2、静态代理模式类图\"></a>2.2、静态代理模式类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"2-3、动态代理示例程序类图\"><a href=\"#2-3、动态代理示例程序类图\" class=\"headerlink\" title=\"2.3、动态代理示例程序类图\"></a>2.3、动态代理示例程序类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/05.jpg\" alt=\"图5\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"2-4、动态代理模式类图\"><a href=\"#2-4、动态代理模式类图\" class=\"headerlink\" title=\"2.4、动态代理模式类图\"></a>2.4、动态代理模式类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_009_20200718/06.jpg\" alt=\"图6\" width=\"80%\" height=\"80%\"></div>\n","slug":"1-009","updated":"2020-07-18T13:39:04.296Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2020/07/18/1-009/","excerpt":"","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.elfli.cn/categories/后端/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.elfli.cn/tags/读书笔记/"},{"name":"《Head First设计模式》","slug":"《Head-First设计模式》","permalink":"https://blog.elfli.cn/tags/《Head-First设计模式》/"}]},{"title":"《Head First设计模式》读书笔记二","date":"2020-07-12T16:00:00.000Z","path":"2020/07/13/1-007/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！ 策略模式（Strategy Pattern）和状态模式（State Pattern）一、策略模式 定义：策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 对应的设计原则： 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 多用组合，少用继承 1.1、示例程序类图 1.2、模式类图 二、状态模式 定义：状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 对应的设计原则： 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 多用组合，少用继承 2.1、示例程序类图 2.2、模式类图","raw":"---\ntitle: 《Head First设计模式》读书笔记二\n\ndate: 2020-07-13\n\ntoc: true\n\ncategories: \n- 后端\n\ntags: \n- 《Head First设计模式》\n- 读书笔记\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---\n\n策略模式（Strategy Pattern）和状态模式（State Pattern）\n=====\n\n一、策略模式\n-----\n> 定义：策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。\n-----\n> 对应的设计原则：\n* 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。\n* 针对接口编程，而不是针对实现编程。\n* 多用组合，少用继承\n\n1.1、示例程序类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_007_20200713/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n1.2、模式类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_007_20200713/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n二、状态模式\n-----\n> 定义：状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。\n-----\n> 对应的设计原则：\n* 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。\n* 针对接口编程，而不是针对实现编程。\n* 多用组合，少用继承\n\n2.1、示例程序类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_007_20200713/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n2.2、模式类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_007_20200713/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>\n","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n<h1 id=\"策略模式（Strategy-Pattern）和状态模式（State-Pattern）\"><a href=\"#策略模式（Strategy-Pattern）和状态模式（State-Pattern）\" class=\"headerlink\" title=\"策略模式（Strategy Pattern）和状态模式（State Pattern）\"></a>策略模式（Strategy Pattern）和状态模式（State Pattern）</h1><h2 id=\"一、策略模式\"><a href=\"#一、策略模式\" class=\"headerlink\" title=\"一、策略模式\"></a>一、策略模式</h2><blockquote>\n<p>定义：策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对应的设计原则：</p>\n<ul>\n<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>\n<li>针对接口编程，而不是针对实现编程。</li>\n<li>多用组合，少用继承</li>\n</ul>\n</blockquote>\n<h2 id=\"1-1、示例程序类图\"><a href=\"#1-1、示例程序类图\" class=\"headerlink\" title=\"1.1、示例程序类图\"></a>1.1、示例程序类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_007_20200713/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"1-2、模式类图\"><a href=\"#1-2、模式类图\" class=\"headerlink\" title=\"1.2、模式类图\"></a>1.2、模式类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_007_20200713/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"二、状态模式\"><a href=\"#二、状态模式\" class=\"headerlink\" title=\"二、状态模式\"></a>二、状态模式</h2><blockquote>\n<p>定义：状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对应的设计原则：</p>\n<ul>\n<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>\n<li>针对接口编程，而不是针对实现编程。</li>\n<li>多用组合，少用继承</li>\n</ul>\n</blockquote>\n<h2 id=\"2-1、示例程序类图\"><a href=\"#2-1、示例程序类图\" class=\"headerlink\" title=\"2.1、示例程序类图\"></a>2.1、示例程序类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_007_20200713/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"2-2、模式类图\"><a href=\"#2-2、模式类图\" class=\"headerlink\" title=\"2.2、模式类图\"></a>2.2、模式类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_007_20200713/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>\n","slug":"1-007","updated":"2020-07-18T13:49:15.306Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2020/07/13/1-007/","excerpt":"","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.elfli.cn/categories/后端/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.elfli.cn/tags/读书笔记/"},{"name":"《Head First设计模式》","slug":"《Head-First设计模式》","permalink":"https://blog.elfli.cn/tags/《Head-First设计模式》/"}]},{"title":"《Head First设计模式》读书笔记一","date":"2020-07-12T16:00:00.000Z","path":"2020/07/13/1-008/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！ 迭代器（Iterator Pattern）和组合模式（Composite Pattern）一、迭代器模式 定义：迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。优点：迭代器模式让我们能游走于聚合内的每一个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。 对应的设计原则： 单一责任原则：一个类应该只有一个引起变化的原因 1.1、示例程序类图 1.2、模式类图 二、组合模式 定义：组合模式允许你将对象组合成树形结构来表现”整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。优点：组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象。使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。 对应的设计原则： 单一责任原则：一个类应该只有一个引起变化的原因 2.1、示例程序类图 2.2、模式类图","raw":"---\ntitle: 《Head First设计模式》读书笔记一\n\ndate: 2020-07-13\n\ntoc: true\n\ncategories: \n- 后端\n\ntags: \n- 《Head First设计模式》\n- 读书笔记\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---\n\n迭代器（Iterator Pattern）和组合模式（Composite Pattern）\n=====\n\n一、迭代器模式\n-----\n> 定义：迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。\n> 优点：迭代器模式让我们能游走于聚合内的每一个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。\n-----\n> 对应的设计原则：\n* 单一责任原则：一个类应该只有一个引起变化的原因\n\n1.1、示例程序类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_008_20200713/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n1.2、模式类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_008_20200713/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n二、组合模式\n-----\n> 定义：组合模式允许你将对象组合成树形结构来表现\"整体/部分\"层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。\n> 优点：组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象。使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。\n-----\n> 对应的设计原则：\n* 单一责任原则：一个类应该只有一个引起变化的原因\n\n2.1、示例程序类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_008_20200713/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n2.2、模式类图\n-----\n<div align=\"center\"><img src=\"/assets/img/blog/1_008_20200713/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>\n","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n<h1 id=\"迭代器（Iterator-Pattern）和组合模式（Composite-Pattern）\"><a href=\"#迭代器（Iterator-Pattern）和组合模式（Composite-Pattern）\" class=\"headerlink\" title=\"迭代器（Iterator Pattern）和组合模式（Composite Pattern）\"></a>迭代器（Iterator Pattern）和组合模式（Composite Pattern）</h1><h2 id=\"一、迭代器模式\"><a href=\"#一、迭代器模式\" class=\"headerlink\" title=\"一、迭代器模式\"></a>一、迭代器模式</h2><blockquote>\n<p>定义：迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。<br>优点：迭代器模式让我们能游走于聚合内的每一个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对应的设计原则：</p>\n<ul>\n<li>单一责任原则：一个类应该只有一个引起变化的原因</li>\n</ul>\n</blockquote>\n<h2 id=\"1-1、示例程序类图\"><a href=\"#1-1、示例程序类图\" class=\"headerlink\" title=\"1.1、示例程序类图\"></a>1.1、示例程序类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_008_20200713/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"1-2、模式类图\"><a href=\"#1-2、模式类图\" class=\"headerlink\" title=\"1.2、模式类图\"></a>1.2、模式类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_008_20200713/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"二、组合模式\"><a href=\"#二、组合模式\" class=\"headerlink\" title=\"二、组合模式\"></a>二、组合模式</h2><blockquote>\n<p>定义：组合模式允许你将对象组合成树形结构来表现”整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。<br>优点：组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象。使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对应的设计原则：</p>\n<ul>\n<li>单一责任原则：一个类应该只有一个引起变化的原因</li>\n</ul>\n</blockquote>\n<h2 id=\"2-1、示例程序类图\"><a href=\"#2-1、示例程序类图\" class=\"headerlink\" title=\"2.1、示例程序类图\"></a>2.1、示例程序类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_008_20200713/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n<h2 id=\"2-2、模式类图\"><a href=\"#2-2、模式类图\" class=\"headerlink\" title=\"2.2、模式类图\"></a>2.2、模式类图</h2><div align=\"center\"><img src=\"/assets/img/blog/1_008_20200713/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>\n","slug":"1-008","updated":"2020-07-18T13:49:15.297Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2020/07/13/1-008/","excerpt":"","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.elfli.cn/categories/后端/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.elfli.cn/tags/读书笔记/"},{"name":"《Head First设计模式》","slug":"《Head-First设计模式》","permalink":"https://blog.elfli.cn/tags/《Head-First设计模式》/"}]},{"title":"《深入理解Java虚拟机》读书笔记一","date":"2019-07-01T16:00:00.000Z","path":"2019/07/02/1-006/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！ 一、虚拟机性能监控和故障处理工具（第四章）1.1、JDK命令行工具这些工具作为JDK提供的故障处理工具，都是非常稳定而且功能强大的，能在处理应用程序性能问题、定位故障时发挥很大的作用，如下图： 其中常用的几个监控和故障处理工具如下表所示，使用command -help可以查看命令帮助： 名称 主要作用 jps JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程 jstat JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据 jinfo Configuration Info for Java，显示虚拟机配置信息 jmap Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件） jhat JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果 jstack Stack Trace for Java，显示虚拟机的线程快照 (1). jps：虚拟机进程状况工具(2). jstat：虚拟机统计信息监视工具(3). jinfo：Java配置信息工具(4). jmap：Java内存映像工具(5). jhat：虚拟机堆转储快照分析工具(5). jstack：Java堆栈跟踪工具","raw":"---\ntitle: 《深入理解Java虚拟机》读书笔记一\n\ndate: 2019-07-02\n\ntoc: true\n\ncategories: \n- 后端\n\ntags: \n- 《深入理解Java虚拟机》\n- 读书笔记\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---\n\n一、虚拟机性能监控和故障处理工具（第四章）\n=====\n1.1、JDK命令行工具\n-----\n这些工具作为JDK提供的故障处理工具，都是非常稳定而且功能强大的，能在处理应用程序性能问题、定位故障时发挥很大的作用，如下图：\n<div align=\"center\"><img src=\"/assets/img/blog/1_006_20190702/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div><br>\n其中常用的几个监控和故障处理工具如下表所示，使用command -help可以查看命令帮助：\n\n名称|主要作用\n:--|:--\njps|JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程\njstat|JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据\njinfo|Configuration Info for Java，显示虚拟机配置信息\njmap|Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）\njhat|JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果\njstack|Stack Trace for Java，显示虚拟机的线程快照\n\n### (1). jps：虚拟机进程状况工具\n### (2). jstat：虚拟机统计信息监视工具\n### (3). jinfo：Java配置信息工具\n### (4). jmap：Java内存映像工具\n### (5). jhat：虚拟机堆转储快照分析工具\n### (5). jstack：Java堆栈跟踪工具","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n<h1 id=\"一、虚拟机性能监控和故障处理工具（第四章）\"><a href=\"#一、虚拟机性能监控和故障处理工具（第四章）\" class=\"headerlink\" title=\"一、虚拟机性能监控和故障处理工具（第四章）\"></a>一、虚拟机性能监控和故障处理工具（第四章）</h1><h2 id=\"1-1、JDK命令行工具\"><a href=\"#1-1、JDK命令行工具\" class=\"headerlink\" title=\"1.1、JDK命令行工具\"></a>1.1、JDK命令行工具</h2><p>这些工具作为JDK提供的故障处理工具，都是非常稳定而且功能强大的，能在处理应用程序性能问题、定位故障时发挥很大的作用，如下图：</p>\n<p><div align=\"center\"><img src=\"/assets/img/blog/1_006_20190702/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div><br><br>其中常用的几个监控和故障处理工具如下表所示，使用command -help可以查看命令帮助：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:left\">主要作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">jps</td>\n<td style=\"text-align:left\">JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jstat</td>\n<td style=\"text-align:left\">JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jinfo</td>\n<td style=\"text-align:left\">Configuration Info for Java，显示虚拟机配置信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jmap</td>\n<td style=\"text-align:left\">Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jhat</td>\n<td style=\"text-align:left\">JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">jstack</td>\n<td style=\"text-align:left\">Stack Trace for Java，显示虚拟机的线程快照</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-jps：虚拟机进程状况工具\"><a href=\"#1-jps：虚拟机进程状况工具\" class=\"headerlink\" title=\"(1). jps：虚拟机进程状况工具\"></a>(1). jps：虚拟机进程状况工具</h3><h3 id=\"2-jstat：虚拟机统计信息监视工具\"><a href=\"#2-jstat：虚拟机统计信息监视工具\" class=\"headerlink\" title=\"(2). jstat：虚拟机统计信息监视工具\"></a>(2). jstat：虚拟机统计信息监视工具</h3><h3 id=\"3-jinfo：Java配置信息工具\"><a href=\"#3-jinfo：Java配置信息工具\" class=\"headerlink\" title=\"(3). jinfo：Java配置信息工具\"></a>(3). jinfo：Java配置信息工具</h3><h3 id=\"4-jmap：Java内存映像工具\"><a href=\"#4-jmap：Java内存映像工具\" class=\"headerlink\" title=\"(4). jmap：Java内存映像工具\"></a>(4). jmap：Java内存映像工具</h3><h3 id=\"5-jhat：虚拟机堆转储快照分析工具\"><a href=\"#5-jhat：虚拟机堆转储快照分析工具\" class=\"headerlink\" title=\"(5). jhat：虚拟机堆转储快照分析工具\"></a>(5). jhat：虚拟机堆转储快照分析工具</h3><h3 id=\"5-jstack：Java堆栈跟踪工具\"><a href=\"#5-jstack：Java堆栈跟踪工具\" class=\"headerlink\" title=\"(5). jstack：Java堆栈跟踪工具\"></a>(5). jstack：Java堆栈跟踪工具</h3>","slug":"1-006","updated":"2020-07-18T13:49:15.311Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2019/07/02/1-006/","excerpt":"","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.elfli.cn/categories/后端/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.elfli.cn/tags/读书笔记/"},{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","permalink":"https://blog.elfli.cn/tags/《深入理解Java虚拟机》/"}]},{"title":"Java面试整理（自用）","date":"2019-06-30T16:00:00.000Z","path":"2019/07/01/1-003/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！ IO/NIO多线程、线程池集合JDK和Cglib代理JDK和Tomcat类加载机制、线程上下文类加载器JVM的GC、锁机制、性能监控和调优Spring实现原理、注解、MVC模式Mybatis实现原理、动态SQLRedis面试题消息中间件面试题数据库分库分表分布式系统数据库事务mysql执行顺序、执行计划、索引、调优Docker容器技术分布式微服务Java常用加密算法","raw":"---\ntitle: Java面试整理（自用）\n\ndate: 2019-07-01\n\ntoc: true\n\ncategories: \n- 后端\n\ntags: \n- Java\n- 技术随笔\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---\n\n## IO/NIO\n\n## 多线程、线程池\n\n## 集合\n\n## JDK和Cglib代理\n\n## JDK和Tomcat类加载机制、线程上下文类加载器\n\n## JVM的GC、锁机制、性能监控和调优\n\n## Spring实现原理、注解、MVC模式\n\n## Mybatis实现原理、动态SQL\n\n## Redis面试题\n\n## 消息中间件面试题\n\n## 数据库分库分表\n\n## 分布式系统\n\n## 数据库事务\n\n## mysql执行顺序、执行计划、索引、调优\n\n## Docker容器技术\n\n## 分布式微服务\n\n## Java常用加密算法\n","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n<h2 id=\"IO-NIO\"><a href=\"#IO-NIO\" class=\"headerlink\" title=\"IO/NIO\"></a>IO/NIO</h2><h2 id=\"多线程、线程池\"><a href=\"#多线程、线程池\" class=\"headerlink\" title=\"多线程、线程池\"></a>多线程、线程池</h2><h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h2 id=\"JDK和Cglib代理\"><a href=\"#JDK和Cglib代理\" class=\"headerlink\" title=\"JDK和Cglib代理\"></a>JDK和Cglib代理</h2><h2 id=\"JDK和Tomcat类加载机制、线程上下文类加载器\"><a href=\"#JDK和Tomcat类加载机制、线程上下文类加载器\" class=\"headerlink\" title=\"JDK和Tomcat类加载机制、线程上下文类加载器\"></a>JDK和Tomcat类加载机制、线程上下文类加载器</h2><h2 id=\"JVM的GC、锁机制、性能监控和调优\"><a href=\"#JVM的GC、锁机制、性能监控和调优\" class=\"headerlink\" title=\"JVM的GC、锁机制、性能监控和调优\"></a>JVM的GC、锁机制、性能监控和调优</h2><h2 id=\"Spring实现原理、注解、MVC模式\"><a href=\"#Spring实现原理、注解、MVC模式\" class=\"headerlink\" title=\"Spring实现原理、注解、MVC模式\"></a>Spring实现原理、注解、MVC模式</h2><h2 id=\"Mybatis实现原理、动态SQL\"><a href=\"#Mybatis实现原理、动态SQL\" class=\"headerlink\" title=\"Mybatis实现原理、动态SQL\"></a>Mybatis实现原理、动态SQL</h2><h2 id=\"Redis面试题\"><a href=\"#Redis面试题\" class=\"headerlink\" title=\"Redis面试题\"></a>Redis面试题</h2><h2 id=\"消息中间件面试题\"><a href=\"#消息中间件面试题\" class=\"headerlink\" title=\"消息中间件面试题\"></a>消息中间件面试题</h2><h2 id=\"数据库分库分表\"><a href=\"#数据库分库分表\" class=\"headerlink\" title=\"数据库分库分表\"></a>数据库分库分表</h2><h2 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h2><h2 id=\"数据库事务\"><a href=\"#数据库事务\" class=\"headerlink\" title=\"数据库事务\"></a>数据库事务</h2><h2 id=\"mysql执行顺序、执行计划、索引、调优\"><a href=\"#mysql执行顺序、执行计划、索引、调优\" class=\"headerlink\" title=\"mysql执行顺序、执行计划、索引、调优\"></a>mysql执行顺序、执行计划、索引、调优</h2><h2 id=\"Docker容器技术\"><a href=\"#Docker容器技术\" class=\"headerlink\" title=\"Docker容器技术\"></a>Docker容器技术</h2><h2 id=\"分布式微服务\"><a href=\"#分布式微服务\" class=\"headerlink\" title=\"分布式微服务\"></a>分布式微服务</h2><h2 id=\"Java常用加密算法\"><a href=\"#Java常用加密算法\" class=\"headerlink\" title=\"Java常用加密算法\"></a>Java常用加密算法</h2>","slug":"1-003","updated":"2020-07-18T13:49:15.284Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2019/07/01/1-003/","excerpt":"","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.elfli.cn/categories/后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.elfli.cn/tags/Java/"},{"name":"技术随笔","slug":"技术随笔","permalink":"https://blog.elfli.cn/tags/技术随笔/"}]},{"title":"《Spring微服务实战》读书笔记一","date":"2019-06-30T16:00:00.000Z","path":"2019/07/01/1-005/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！","raw":"---\ntitle: 《Spring微服务实战》读书笔记一\n\ndate: 2019-07-01\n\ntoc: true\n\ncategories: \n- 后端\n\ntags: \n- 《Spring微服务实战》\n- 读书笔记\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n","slug":"1-005","updated":"2020-07-18T13:49:15.293Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2019/07/01/1-005/","excerpt":"","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.elfli.cn/categories/后端/"}],"tags":[{"name":"《Spring微服务实战》","slug":"《Spring微服务实战》","permalink":"https://blog.elfli.cn/tags/《Spring微服务实战》/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.elfli.cn/tags/读书笔记/"}]},{"title":"《Spring Boot实战》读书笔记一","date":"2019-06-30T16:00:00.000Z","path":"2019/07/01/1-004/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！ Spring Boot是什么？直接引用书中的内容，最重要的就是以下四个核心： 自动配置：针对Spring应用常见的应用功能，Spring Boot能自动提供相关配置； 起步依赖：告诉Spring Boot需要什么功能，它就能自动引入需要的库； 命令行界面：Spring Boot的可选特性，借此只需写代码就能完成完整的应用程序，无需传统的项目构建； Actuator：能够深入运行中的Spring Boot应用程序，用来监控和度量Spring Boot应用程序。 一、入门（第一章）1.1、自动配置以Spring的数据库配置为例来简单说明一下，传统的Spring项目一定要在应用程序上下文配置JdbcTemplate这个Bean，配置如下：1234567891011121314@Beanpublic JdbcTemplate jdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource);&#125;@Beanpublic DataSource dataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setUrl(env.getProperty(\"url\")); dataSource.setDriverClassName(env.getProperty(\"driverName\")); dataSource.setUsername(env.getProperty(\"datausername\")); dataSource.setPassword(env.getProperty(\"password\")); return dataSource;&#125; Spring Boot会对这些常见配置进行自动配置，如果Spring Boot在应用程序的Classpath里发现JdbcTemplate，那么它会自定配置一个JdbcTemplate的Bean，接下来只需要在application.yml文件中配置一下数据库的相关连接信息就行了。 1.2、起步依赖 Spring Boot利用Maven和Gradle的传递依赖特性，把常用库聚合在一起，组成了几个为特定功能而定制的依赖。举个例子，我们如果想要构建一个Spring的Web应用程序，传统的Spring需要引入spring-core、spring-web、spring-webmvc等很多依赖才行，而且需要自己管理每一个依赖的版本。但是如果使用Spring Boot的起步依赖，就只需要添加spring-boot-starter-web即可，而且不需要担心版本不兼容的问题，这些都是经过严格测试的。 1.3、命令行界面 Spring Boot CLI利用了自动配置和起步依赖，可以让开发者只专注于代码本身。 1.4、Actuator Actuator可以窥探到应用程序内部的细节如下： Spring应用程序上下文里配置的Bean Spring Boot的自动配置做出的决策 应用程序取到的环境变量、系统属性、配置属性和命令行参数 应用程序里线程的当前状态 应用程序最近处理过的HTTP请求的追踪情况 各种和内存用量、垃圾回收、Web请求以及数据源用量相关的指标 1.5、idea创建Spring Boot项目 第一步：使用Spring Initializr 第二步：填写项目信息第三步：选择项目依赖第四步：项目命名并完成最终项目结构如下： 二、总结以上是Spring Boot的核心功能整理，以及如何在idea中创建Spring Boot项目，对书中的重点内容进行了提取，仅供参考！","raw":"---\ntitle: 《Spring Boot实战》读书笔记一\n\ndate: 2019-07-01\n\ntoc: true\n\ncategories: \n- 后端\n\ntags: \n- 《Spring Boot实战》\n- 读书笔记\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---\n> Spring Boot是什么？直接引用书中的内容，最重要的就是以下四个核心：\n* 自动配置：针对Spring应用常见的应用功能，Spring Boot能自动提供相关配置；\n* 起步依赖：告诉Spring Boot需要什么功能，它就能自动引入需要的库；\n* 命令行界面：Spring Boot的可选特性，借此只需写代码就能完成完整的应用程序，无需传统的项目构建；\n* Actuator：能够深入运行中的Spring Boot应用程序，用来监控和度量Spring Boot应用程序。\n\n一、入门（第一章）\n=====\n1.1、自动配置\n-----\n以Spring的数据库配置为例来简单说明一下，传统的Spring项目一定要在应用程序上下文配置JdbcTemplate这个Bean，配置如下：\n```java\n@Bean\npublic JdbcTemplate jdbcTemplate(DataSource dataSource) {\n    return new JdbcTemplate(dataSource);\n}\n\n@Bean\npublic DataSource dataSource() {\n    DriverManagerDataSource dataSource = new DriverManagerDataSource();\n    dataSource.setUrl(env.getProperty(\"url\"));\n    dataSource.setDriverClassName(env.getProperty(\"driverName\"));\n    dataSource.setUsername(env.getProperty(\"datausername\"));\n    dataSource.setPassword(env.getProperty(\"password\"));\n    return dataSource;\n}\n```\nSpring Boot会对这些常见配置进行自动配置，如果Spring Boot在应用程序的Classpath里发现JdbcTemplate，那么它会自定配置一个JdbcTemplate的Bean，接下来只需要在application.yml文件中配置一下数据库的相关连接信息就行了。\n\n1.2、起步依赖\n-----\n> Spring Boot利用Maven和Gradle的传递依赖特性，把常用库聚合在一起，组成了几个为特定功能而定制的依赖。\n举个例子，我们如果想要构建一个Spring的Web应用程序，传统的Spring需要引入spring-core、spring-web、spring-webmvc等很多依赖才行，而且需要自己管理每一个依赖的版本。但是如果使用Spring Boot的起步依赖，就只需要添加spring-boot-starter-web即可，而且不需要担心版本不兼容的问题，这些都是经过严格测试的。\n\n1.3、命令行界面\n-----\n> Spring Boot CLI利用了自动配置和起步依赖，可以让开发者只专注于代码本身。\n\n1.4、Actuator\n-----\n> Actuator可以窥探到应用程序内部的细节如下：\n* Spring应用程序上下文里配置的Bean\n* Spring Boot的自动配置做出的决策\n* 应用程序取到的环境变量、系统属性、配置属性和命令行参数\n* 应用程序里线程的当前状态\n* 应用程序最近处理过的HTTP请求的追踪情况\n* 各种和内存用量、垃圾回收、Web请求以及数据源用量相关的指标\n\n1.5、idea创建Spring Boot项目\n-----\n> 第一步：使用Spring Initializr\n> <br>\n> <div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n> 第二步：填写项目信息<br>\n> <div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n> 第三步：选择项目依赖<br>\n> <div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n> 第四步：项目命名并完成<br>\n> <div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>\n> 最终项目结构如下：<br>\n> <div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/05.jpg\" alt=\"图5\" width=\"80%\" height=\"80%\"></div>\n\n二、总结\n=====\n以上是Spring Boot的核心功能整理，以及如何在idea中创建Spring Boot项目，对书中的重点内容进行了提取，仅供参考！","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n<blockquote>\n<p>Spring Boot是什么？直接引用书中的内容，最重要的就是以下四个核心：</p>\n<ul>\n<li>自动配置：针对Spring应用常见的应用功能，Spring Boot能自动提供相关配置；</li>\n<li>起步依赖：告诉Spring Boot需要什么功能，它就能自动引入需要的库；</li>\n<li>命令行界面：Spring Boot的可选特性，借此只需写代码就能完成完整的应用程序，无需传统的项目构建；</li>\n<li>Actuator：能够深入运行中的Spring Boot应用程序，用来监控和度量Spring Boot应用程序。</li>\n</ul>\n</blockquote>\n<h1 id=\"一、入门（第一章）\"><a href=\"#一、入门（第一章）\" class=\"headerlink\" title=\"一、入门（第一章）\"></a>一、入门（第一章）</h1><h2 id=\"1-1、自动配置\"><a href=\"#1-1、自动配置\" class=\"headerlink\" title=\"1.1、自动配置\"></a>1.1、自动配置</h2><p>以Spring的数据库配置为例来简单说明一下，传统的Spring项目一定要在应用程序上下文配置JdbcTemplate这个Bean，配置如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">(DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(dataSource);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DriverManagerDataSource dataSource = <span class=\"keyword\">new</span> DriverManagerDataSource();</span><br><span class=\"line\">    dataSource.setUrl(env.getProperty(<span class=\"string\">\"url\"</span>));</span><br><span class=\"line\">    dataSource.setDriverClassName(env.getProperty(<span class=\"string\">\"driverName\"</span>));</span><br><span class=\"line\">    dataSource.setUsername(env.getProperty(<span class=\"string\">\"datausername\"</span>));</span><br><span class=\"line\">    dataSource.setPassword(env.getProperty(<span class=\"string\">\"password\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Spring Boot会对这些常见配置进行自动配置，如果Spring Boot在应用程序的Classpath里发现JdbcTemplate，那么它会自定配置一个JdbcTemplate的Bean，接下来只需要在application.yml文件中配置一下数据库的相关连接信息就行了。</p>\n<h2 id=\"1-2、起步依赖\"><a href=\"#1-2、起步依赖\" class=\"headerlink\" title=\"1.2、起步依赖\"></a>1.2、起步依赖</h2><blockquote>\n<p>Spring Boot利用Maven和Gradle的传递依赖特性，把常用库聚合在一起，组成了几个为特定功能而定制的依赖。<br>举个例子，我们如果想要构建一个Spring的Web应用程序，传统的Spring需要引入spring-core、spring-web、spring-webmvc等很多依赖才行，而且需要自己管理每一个依赖的版本。但是如果使用Spring Boot的起步依赖，就只需要添加spring-boot-starter-web即可，而且不需要担心版本不兼容的问题，这些都是经过严格测试的。</p>\n</blockquote>\n<h2 id=\"1-3、命令行界面\"><a href=\"#1-3、命令行界面\" class=\"headerlink\" title=\"1.3、命令行界面\"></a>1.3、命令行界面</h2><blockquote>\n<p>Spring Boot CLI利用了自动配置和起步依赖，可以让开发者只专注于代码本身。</p>\n</blockquote>\n<h2 id=\"1-4、Actuator\"><a href=\"#1-4、Actuator\" class=\"headerlink\" title=\"1.4、Actuator\"></a>1.4、Actuator</h2><blockquote>\n<p>Actuator可以窥探到应用程序内部的细节如下：</p>\n<ul>\n<li>Spring应用程序上下文里配置的Bean</li>\n<li>Spring Boot的自动配置做出的决策</li>\n<li>应用程序取到的环境变量、系统属性、配置属性和命令行参数</li>\n<li>应用程序里线程的当前状态</li>\n<li>应用程序最近处理过的HTTP请求的追踪情况</li>\n<li>各种和内存用量、垃圾回收、Web请求以及数据源用量相关的指标</li>\n</ul>\n</blockquote>\n<h2 id=\"1-5、idea创建Spring-Boot项目\"><a href=\"#1-5、idea创建Spring-Boot项目\" class=\"headerlink\" title=\"1.5、idea创建Spring Boot项目\"></a>1.5、idea创建Spring Boot项目</h2><blockquote>\n<p>第一步：使用Spring Initializr<br><br></p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div><br>第二步：填写项目信息<br><br><div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div><br>第三步：选择项目依赖<br><br><div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div><br>第四步：项目命名并完成<br><br><div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div><br>最终项目结构如下：<br><br><div align=\"center\"><img src=\"/assets/img/blog/1_004_20190701/05.jpg\" alt=\"图5\" width=\"80%\" height=\"80%\"></div>\n</blockquote>\n<h1 id=\"二、总结\"><a href=\"#二、总结\" class=\"headerlink\" title=\"二、总结\"></a>二、总结</h1><p>以上是Spring Boot的核心功能整理，以及如何在idea中创建Spring Boot项目，对书中的重点内容进行了提取，仅供参考！</p>\n","slug":"1-004","updated":"2020-07-18T13:49:15.289Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2019/07/01/1-004/","excerpt":"","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.elfli.cn/categories/后端/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://blog.elfli.cn/tags/读书笔记/"},{"name":"《Spring Boot实战》","slug":"《Spring-Boot实战》","permalink":"https://blog.elfli.cn/tags/《Spring-Boot实战》/"}]},{"title":"mysql语句的执行","date":"2019-06-29T16:00:00.000Z","path":"2019/06/30/1-002/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！ 一、mysql执行1.1、执行语句mysql数据库在做优化的时候，往往需要知道SQL语句的执行顺序才能够更好的进行优化。首先mysql有以下执行语句：from、join、on、where、group by、having、select、distinct、order by、limit。 在这里关于join语句简单介绍一下join的原理，参考自https://www.cnblogs.com/fudashi/p/7506877.html，个人觉得总结的很到位： 下面是join语句的数学集合表示： join语句的连接算法有Nested Loop Join(NLJ)循环嵌套算法和Block Nested Loop Join(BNLJ)块循环嵌套算法，详细的算法说明请参考上面的引用链接；至于如何提高join的效率，可以参考下面的原则： 小表驱动大表能够减少内循环的次数从而提高连接效率； 设置合理的缓冲区大小能够提高连接效率； 在被驱动表建立索引能够提高连接效率； 优先选择驱动表的属性进行排序能够提高连接效率； 1.2、执行顺序此处参考来自MySql执行顺序及执行计划 (1). from table1, table2 将table1和table2中的数据产生笛卡尔积，生成虚拟表t1，作为下一步的输入(2). join table3 根据join类型进行表连接操作(3). on table1.column = table3.column 确定表的绑定条件，由t1产生虚拟表t2(4). where 对虚拟表t2产生的结果进行过滤，产生虚拟表t3(5). group by 对虚拟表t3进行分组，产生虚拟表t4，此处开始使用select中的别名，后面的语句中都可以使用(6). having 对分组后的记录进行聚合，在该步骤执行聚合函数，产生虚拟表t5(7). select 对虚拟表t5进行列筛选，产生虚拟表t6(8). distinct 对虚拟表t6进行去重，产生虚拟表t7(9). order by 对t7中的数据进行排序，产生虚拟表t8(10). limit 对虚拟表t8进行分页，产生虚拟表t9 个人总结下来一共有这些关键点：先确定表，再筛选行，分组聚合后再筛选列，最后去重排序和分页。下面举例说明一下，创建一个学生表、学生成绩表以及年级表：1234567891011121314151617181920212223242526272829303132333435363738394041create table test.t_student( id int auto_increment primary key, classId int null comment '年级表id', age int default '0' not null comment '学生年龄', name varchar(20) null comment '学生姓名', constraint t_student_id_uindex unique (id)) comment '学生表'; create table test.t_student_score( id int auto_increment primary key, parentId int null comment '父表，学生表', score decimal(10, 1) default '0.0' not null comment '分数', course varchar(10) null, constraint t_student_score_id_uindex unique (id)) comment '学生成绩表'; create table test.t_class( id int auto_increment primary key, name varchar(20) null comment '学科名称', level int default '0' not null comment '级别', constraint t_class_id_uindex unique (id)) comment '年级表'; 执行下面一个查询1，主要是查询前五条年级级别大于1、年龄大于10且所有课程总分大于100的学生姓名和总分，并按照总分数升序排列：123456789101112select A.id as studentId, A.name, sum(B.score) as sumScorefrom t_student A left join t_student_score B on B.parentId = A.id join t_class C on C.id = A.classId and C.level &gt; 1where A.age &gt; 10group by studentIdhaving sumScore &gt; 100order by sumScorelimit 0, 5; 上述语句的执行顺序是这样的： 执行”from t_student A”语句，得到表A的记录； 执行”left join t_student_score B on B.parentId = A.id”语句，以表A驱动表B进行连接操作，挑选on条件成立的记录； 执行”join t_class C on C.id = A.classId and C.level &gt; 1”语句，以表A驱动表C进行连接操作，挑选on条件成立的记录； 执行”where A.age &gt; 10”语句，筛选出where条件成立的记录； 执行”group by studentId”语句，对上一步产生的记录进行分组操作，此处可以使用studentId别名； 执行”having sumScore &gt; 100”语句，对分组结果筛选出having条件成立的记录，此处开始执行聚合函数； 执行”select A.id as studentId, A.name, sum(B.score) as sumScore”语句，对上一步结果进行列筛选； 执行”order by sumScore”语句，对上一步结果根据sumScore进行升序排列； 执行”limit 0, 5”语句，对上一步结果进行分页操作； 1.3、执行计划mysql中使用explain命令获取SQL语句的执行计划，例如上述的查询1，执行explain后的结果如下： 下面针对explain输出结果字段进行说明，参考自https://yq.aliyun.com/articles/602513/： id: select查询序列号，id相同，执行顺序由上至下；id不同，id值越大优先级越高；select_type: 查询数据的操作类型，有如下几种： 类型 说明 simple 简单查询，不包含子查询或union primary 包含复杂的子查询，最外层查询标记为该值 subQuery 在select或where里包含的子查询被标记为该值 derived 在from列表中包含的子查询被标记为该值，mysql会递归这些子查询，把结果放入临时表 union 第二个select语句出现在union语句后被标记为该值 union result 从union后的结果中查询数据的select被标记为该值 table: 该行数据是关于哪张表partitions: 匹配的分区type: 表的连接类型，有如下几种值，性能由高到底： 类型 说明 NULL 不用扫描表或索引 system 表中只有一行记录 const 通过索引一次就能找到，只匹配一行记录 eq_ref 通过唯一索引查询，每一个索引键只有一行记录与之匹配，常见于主键或唯一索引扫描 ref 通过非唯一性索引查询，返回每一个索引键对应的多行记录，常见于带索引的列使用=操作符 range 通过索引查询指定范围的行，常见于带索引的列使用between、&gt;和&lt;操作符 index 只遍历索引树 ALL 全表扫描 possible_keys: 指出mysql使用哪个索引在该表找到行记录。如果该值为NULL，说明没有使用索引，可以建立索引提高性能key: 指出mysql实际使用的索引。如果为NULL，则没有使用索引查询key_len: 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。显示的是索引字段的最大长度，并非实际使用长度ref: 显示该表的索引字段关联了哪张表的哪个字段rows: 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好filtered: 返回结果的行数占读取行数的百分比，值越大越好extra: 包含不适合在其他列中显示但十分重要的额外信息。常见的值如下： 类型 说明 Using filesort mysql对数据使用一个外部索引进行排序，而不是根据表内的索引顺序进行读取，若出现该值则SQL需要优化 Using temporary mysql使用了临时表保存中间结果，常见于order by和group by，若出现该值则SQL需要优化 Using index select操作使用了覆盖索引，避免了数据回行操作，效率不错 Using where select操作使用了where语句限制哪一行 Using join buffer(Block Nested Loop) 使用了连接缓存，括号里表示使用了哪种连接算法 Distinct 发现第一个匹配后，停止为当前的行组合搜索更多的行 二、总结以上就是mysql数据库SQL查询的基础知识，具体SQL如何优化还需要自己多操作。掌握了SQL语句的详细执行计划后，我们就能够根据实际业务来调整SQL语句，使之性能有所提高。","raw":"---\ntitle: mysql语句的执行\n\ndate: 2019-06-30\n\ntoc: true\n\ncategories: \n- 后端\n\ntags: \n- mysql\n- 技术随笔\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---\n\n一、mysql执行\n=====\n1.1、执行语句\n-----\nmysql数据库在做优化的时候，往往需要知道SQL语句的执行顺序才能够更好的进行优化。首先mysql有以下执行语句：\nfrom、join、on、where、group by、having、select、distinct、order by、limit。\n\n在这里关于join语句简单介绍一下join的原理，参考自[https://www.cnblogs.com/fudashi/p/7506877.html](https://www.cnblogs.com/fudashi/p/7506877.html)，个人觉得总结的很到位：\n> 下面是join语句的数学集合表示：\n> <br>\n> <div align=\"center\"><img src=\"/assets/img/blog/1_002_20190630/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div><br>\n> \n> join语句的连接算法有Nested Loop Join(NLJ)循环嵌套算法和Block Nested Loop Join(BNLJ)块循环嵌套算法，详细的算法说明请参考上面的引用链接；至于如何提高join的效率，可以参考下面的原则：\n* 小表驱动大表能够减少内循环的次数从而提高连接效率；\n* 设置合理的缓冲区大小能够提高连接效率；\n* 在被驱动表建立索引能够提高连接效率；\n* 优先选择驱动表的属性进行排序能够提高连接效率；\n\n1.2、执行顺序\n-----\n此处参考来自[MySql执行顺序及执行计划](https://blog.csdn.net/csndhu/article/details/88176564)\n> (1). from table1, table2  将table1和table2中的数据产生笛卡尔积，生成虚拟表t1，作为下一步的输入\n(2). join table3  根据join类型进行表连接操作\n(3). on table1.column = table3.column 确定表的绑定条件，由t1产生虚拟表t2\n(4). where  对虚拟表t2产生的结果进行过滤，产生虚拟表t3\n(5). group by  对虚拟表t3进行分组，产生虚拟表t4，此处开始使用select中的别名，后面的语句中都可以使用\n(6). having  对分组后的记录进行聚合，在该步骤执行聚合函数，产生虚拟表t5\n(7). select  对虚拟表t5进行列筛选，产生虚拟表t6\n(8). distinct  对虚拟表t6进行去重，产生虚拟表t7\n(9). order by  对t7中的数据进行排序，产生虚拟表t8\n(10). limit  对虚拟表t8进行分页，产生虚拟表t9\n\n个人总结下来一共有这些关键点：先确定表，再筛选行，分组聚合后再筛选列，最后去重排序和分页。\n下面举例说明一下，创建一个学生表、学生成绩表以及年级表：\n```sql\ncreate table test.t_student\n(\n  id      int auto_increment\n    primary key,\n  classId int             null\n  comment '年级表id',\n  age     int default '0' not null\n  comment '学生年龄',\n  name    varchar(20)     null\n  comment '学生姓名',\n  constraint t_student_id_uindex\n  unique (id)\n)\n  comment '学生表';\n  \ncreate table test.t_student_score\n(\n  id       int auto_increment\n    primary key,\n  parentId int                          null\n  comment '父表，学生表',\n  score    decimal(10, 1) default '0.0' not null\n  comment '分数',\n  course   varchar(10)                  null,\n  constraint t_student_score_id_uindex\n  unique (id)\n)\n  comment '学生成绩表';\n  \ncreate table test.t_class\n(\n  id    int auto_increment\n    primary key,\n  name  varchar(20)     null\n  comment '学科名称',\n  level int default '0' not null\n  comment '级别',\n  constraint t_class_id_uindex\n  unique (id)\n)\n  comment '年级表';\n```\n执行下面一个查询1，主要是查询前五条年级级别大于1、年龄大于10且所有课程总分大于100的学生姓名和总分，并按照总分数升序排列：\n```sql\nselect\n  A.id as studentId,\n  A.name,\n  sum(B.score) as sumScore\nfrom t_student A\n  left join t_student_score B on B.parentId = A.id\n  join t_class C on C.id = A.classId and C.level > 1\nwhere A.age > 10\ngroup by studentId\nhaving sumScore > 100\norder by sumScore\nlimit 0, 5;\n```\n上述语句的执行顺序是这样的：\n1. 执行\"from t_student A\"语句，得到表A的记录；\n2. 执行\"left join t_student_score B on B.parentId = A.id\"语句，以表A驱动表B进行连接操作，挑选on条件成立的记录；\n3. 执行\"join t_class C on C.id = A.classId and C.level > 1\"语句，以表A驱动表C进行连接操作，挑选on条件成立的记录；\n4. 执行\"where A.age > 10\"语句，筛选出where条件成立的记录；\n5. 执行\"group by studentId\"语句，对上一步产生的记录进行分组操作，此处可以使用studentId别名；\n6. 执行\"having sumScore > 100\"语句，对分组结果筛选出having条件成立的记录，此处开始执行聚合函数；\n7. 执行\"select A.id as studentId, A.name, sum(B.score) as sumScore\"语句，对上一步结果进行列筛选；\n8. 执行\"order by sumScore\"语句，对上一步结果根据sumScore进行升序排列；\n9. 执行\"limit 0, 5\"语句，对上一步结果进行分页操作；\n\n1.3、执行计划\n-----\nmysql中使用explain命令获取SQL语句的执行计划，例如上述的查询1，执行explain后的结果如下：\n<div align=center>![图2](/assets/img/blog/1_002_20190630/02.jpg)</div>\n下面针对explain输出结果字段进行说明，参考自[https://yq.aliyun.com/articles/602513/](https://yq.aliyun.com/articles/602513/)：\n\n**id:** select查询序列号，id相同，执行顺序由上至下；id不同，id值越大优先级越高；\n**select_type:** 查询数据的操作类型，有如下几种：\n\n类型|说明\n:--|:--\nsimple|简单查询，不包含子查询或union\nprimary|包含复杂的子查询，最外层查询标记为该值\nsubQuery|在select或where里包含的子查询被标记为该值\nderived|在from列表中包含的子查询被标记为该值，mysql会递归这些子查询，把结果放入临时表\nunion|第二个select语句出现在union语句后被标记为该值\nunion result|从union后的结果中查询数据的select被标记为该值\n\n**table:** 该行数据是关于哪张表\n**partitions:** 匹配的分区\n**type:** 表的连接类型，有如下几种值，性能由高到底：\n\n类型|说明\n:--|:--\nNULL|不用扫描表或索引\nsystem|表中只有一行记录\nconst|通过索引一次就能找到，只匹配一行记录\neq_ref|通过唯一索引查询，每一个索引键只有一行记录与之匹配，常见于主键或唯一索引扫描\nref|通过非唯一性索引查询，返回每一个索引键对应的多行记录，常见于带索引的列使用=操作符\nrange|通过索引查询指定范围的行，常见于带索引的列使用between、>和<操作符\nindex|只遍历索引树\nALL|全表扫描\n\n**possible_keys:** 指出mysql使用哪个索引在该表找到行记录。如果该值为NULL，说明没有使用索引，可以建立索引提高性能\n**key:** 指出mysql实际使用的索引。如果为NULL，则没有使用索引查询\n**key_len:** 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。显示的是索引字段的最大长度，并非实际使用长度\n**ref:** 显示该表的索引字段关联了哪张表的哪个字段\n**rows:** 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好\n**filtered:** 返回结果的行数占读取行数的百分比，值越大越好\n**extra:** 包含不适合在其他列中显示但十分重要的额外信息。常见的值如下：\n\n类型|说明\n:--|:--\nUsing filesort|mysql对数据使用一个外部索引进行排序，而不是根据表内的索引顺序进行读取，若出现该值则SQL需要优化\nUsing temporary|mysql使用了临时表保存中间结果，常见于order by和group by，若出现该值则SQL需要优化\nUsing index|select操作使用了覆盖索引，避免了数据回行操作，效率不错\nUsing where|select操作使用了where语句限制哪一行\nUsing join buffer(Block Nested Loop)|使用了连接缓存，括号里表示使用了哪种连接算法\nDistinct|发现第一个匹配后，停止为当前的行组合搜索更多的行\n\n二、总结\n=====\n以上就是mysql数据库SQL查询的基础知识，具体SQL如何优化还需要自己多操作。掌握了SQL语句的详细执行计划后，我们就能够根据实际业务来调整SQL语句，使之性能有所提高。","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n<h1 id=\"一、mysql执行\"><a href=\"#一、mysql执行\" class=\"headerlink\" title=\"一、mysql执行\"></a>一、mysql执行</h1><h2 id=\"1-1、执行语句\"><a href=\"#1-1、执行语句\" class=\"headerlink\" title=\"1.1、执行语句\"></a>1.1、执行语句</h2><p>mysql数据库在做优化的时候，往往需要知道SQL语句的执行顺序才能够更好的进行优化。首先mysql有以下执行语句：<br>from、join、on、where、group by、having、select、distinct、order by、limit。</p>\n<p>在这里关于join语句简单介绍一下join的原理，参考自<a href=\"https://www.cnblogs.com/fudashi/p/7506877.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/fudashi/p/7506877.html</a>，个人觉得总结的很到位：</p>\n<blockquote>\n<p>下面是join语句的数学集合表示：<br><br></p>\n<p><div align=\"center\"><img src=\"/assets/img/blog/1_002_20190630/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div><br></p>\n<p>join语句的连接算法有Nested Loop Join(NLJ)循环嵌套算法和Block Nested Loop Join(BNLJ)块循环嵌套算法，详细的算法说明请参考上面的引用链接；至于如何提高join的效率，可以参考下面的原则：</p>\n<ul>\n<li>小表驱动大表能够减少内循环的次数从而提高连接效率；</li>\n<li>设置合理的缓冲区大小能够提高连接效率；</li>\n<li>在被驱动表建立索引能够提高连接效率；</li>\n<li>优先选择驱动表的属性进行排序能够提高连接效率；</li>\n</ul>\n</blockquote>\n<h2 id=\"1-2、执行顺序\"><a href=\"#1-2、执行顺序\" class=\"headerlink\" title=\"1.2、执行顺序\"></a>1.2、执行顺序</h2><p>此处参考来自<a href=\"https://blog.csdn.net/csndhu/article/details/88176564\" target=\"_blank\" rel=\"noopener\">MySql执行顺序及执行计划</a></p>\n<blockquote>\n<p>(1). from table1, table2  将table1和table2中的数据产生笛卡尔积，生成虚拟表t1，作为下一步的输入<br>(2). join table3  根据join类型进行表连接操作<br>(3). on table1.column = table3.column 确定表的绑定条件，由t1产生虚拟表t2<br>(4). where  对虚拟表t2产生的结果进行过滤，产生虚拟表t3<br>(5). group by  对虚拟表t3进行分组，产生虚拟表t4，此处开始使用select中的别名，后面的语句中都可以使用<br>(6). having  对分组后的记录进行聚合，在该步骤执行聚合函数，产生虚拟表t5<br>(7). select  对虚拟表t5进行列筛选，产生虚拟表t6<br>(8). distinct  对虚拟表t6进行去重，产生虚拟表t7<br>(9). order by  对t7中的数据进行排序，产生虚拟表t8<br>(10). limit  对虚拟表t8进行分页，产生虚拟表t9</p>\n</blockquote>\n<p>个人总结下来一共有这些关键点：先确定表，再筛选行，分组聚合后再筛选列，最后去重排序和分页。<br>下面举例说明一下，创建一个学生表、学生成绩表以及年级表：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test.t_student</span><br><span class=\"line\">(</span><br><span class=\"line\">  <span class=\"keyword\">id</span>      <span class=\"built_in\">int</span> auto_increment</span><br><span class=\"line\">    primary <span class=\"keyword\">key</span>,</span><br><span class=\"line\">  classId <span class=\"built_in\">int</span>             <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'年级表id'</span>,</span><br><span class=\"line\">  age     <span class=\"built_in\">int</span> <span class=\"keyword\">default</span> <span class=\"string\">'0'</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'学生年龄'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">name</span>    <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>)     <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'学生姓名'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">constraint</span> t_student_id_uindex</span><br><span class=\"line\">  <span class=\"keyword\">unique</span> (<span class=\"keyword\">id</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'学生表'</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test.t_student_score</span><br><span class=\"line\">(</span><br><span class=\"line\">  <span class=\"keyword\">id</span>       <span class=\"built_in\">int</span> auto_increment</span><br><span class=\"line\">    primary <span class=\"keyword\">key</span>,</span><br><span class=\"line\">  parentId <span class=\"built_in\">int</span>                          <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'父表，学生表'</span>,</span><br><span class=\"line\">  score    <span class=\"built_in\">decimal</span>(<span class=\"number\">10</span>, <span class=\"number\">1</span>) <span class=\"keyword\">default</span> <span class=\"string\">'0.0'</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'分数'</span>,</span><br><span class=\"line\">  course   <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>)                  <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"keyword\">constraint</span> t_student_score_id_uindex</span><br><span class=\"line\">  <span class=\"keyword\">unique</span> (<span class=\"keyword\">id</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'学生成绩表'</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test.t_class</span><br><span class=\"line\">(</span><br><span class=\"line\">  <span class=\"keyword\">id</span>    <span class=\"built_in\">int</span> auto_increment</span><br><span class=\"line\">    primary <span class=\"keyword\">key</span>,</span><br><span class=\"line\">  <span class=\"keyword\">name</span>  <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>)     <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'学科名称'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">level</span> <span class=\"built_in\">int</span> <span class=\"keyword\">default</span> <span class=\"string\">'0'</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'级别'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">constraint</span> t_class_id_uindex</span><br><span class=\"line\">  <span class=\"keyword\">unique</span> (<span class=\"keyword\">id</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\">  <span class=\"keyword\">comment</span> <span class=\"string\">'年级表'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>执行下面一个查询1，主要是查询前五条年级级别大于1、年龄大于10且所有课程总分大于100的学生姓名和总分，并按照总分数升序排列：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span></span><br><span class=\"line\">  A.id <span class=\"keyword\">as</span> studentId,</span><br><span class=\"line\">  A.name,</span><br><span class=\"line\">  <span class=\"keyword\">sum</span>(B.score) <span class=\"keyword\">as</span> sumScore</span><br><span class=\"line\"><span class=\"keyword\">from</span> t_student A</span><br><span class=\"line\">  <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> t_student_score B <span class=\"keyword\">on</span> B.parentId = A.id</span><br><span class=\"line\">  <span class=\"keyword\">join</span> t_class C <span class=\"keyword\">on</span> C.id = A.classId <span class=\"keyword\">and</span> C.level &gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">where</span> A.age &gt; <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> studentId</span><br><span class=\"line\"><span class=\"keyword\">having</span> sumScore &gt; <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> sumScore</span><br><span class=\"line\"><span class=\"keyword\">limit</span> <span class=\"number\">0</span>, <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure></p>\n<p>上述语句的执行顺序是这样的：</p>\n<ol>\n<li>执行”from t_student A”语句，得到表A的记录；</li>\n<li>执行”left join t_student_score B on B.parentId = A.id”语句，以表A驱动表B进行连接操作，挑选on条件成立的记录；</li>\n<li>执行”join t_class C on C.id = A.classId and C.level &gt; 1”语句，以表A驱动表C进行连接操作，挑选on条件成立的记录；</li>\n<li>执行”where A.age &gt; 10”语句，筛选出where条件成立的记录；</li>\n<li>执行”group by studentId”语句，对上一步产生的记录进行分组操作，此处可以使用studentId别名；</li>\n<li>执行”having sumScore &gt; 100”语句，对分组结果筛选出having条件成立的记录，此处开始执行聚合函数；</li>\n<li>执行”select A.id as studentId, A.name, sum(B.score) as sumScore”语句，对上一步结果进行列筛选；</li>\n<li>执行”order by sumScore”语句，对上一步结果根据sumScore进行升序排列；</li>\n<li>执行”limit 0, 5”语句，对上一步结果进行分页操作；</li>\n</ol>\n<h2 id=\"1-3、执行计划\"><a href=\"#1-3、执行计划\" class=\"headerlink\" title=\"1.3、执行计划\"></a>1.3、执行计划</h2><p>mysql中使用explain命令获取SQL语句的执行计划，例如上述的查询1，执行explain后的结果如下：</p>\n<p><div align=\"center\"><img src=\"/assets/img/blog/1_002_20190630/02.jpg\" alt=\"图2\"></div><br>下面针对explain输出结果字段进行说明，参考自<a href=\"https://yq.aliyun.com/articles/602513/\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/602513/</a>：</p>\n<p><strong>id:</strong> select查询序列号，id相同，执行顺序由上至下；id不同，id值越大优先级越高；<br><strong>select_type:</strong> 查询数据的操作类型，有如下几种：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">simple</td>\n<td style=\"text-align:left\">简单查询，不包含子查询或union</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">primary</td>\n<td style=\"text-align:left\">包含复杂的子查询，最外层查询标记为该值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">subQuery</td>\n<td style=\"text-align:left\">在select或where里包含的子查询被标记为该值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">derived</td>\n<td style=\"text-align:left\">在from列表中包含的子查询被标记为该值，mysql会递归这些子查询，把结果放入临时表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">union</td>\n<td style=\"text-align:left\">第二个select语句出现在union语句后被标记为该值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">union result</td>\n<td style=\"text-align:left\">从union后的结果中查询数据的select被标记为该值</td>\n</tr>\n</tbody>\n</table>\n<p><strong>table:</strong> 该行数据是关于哪张表<br><strong>partitions:</strong> 匹配的分区<br><strong>type:</strong> 表的连接类型，有如下几种值，性能由高到底：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">NULL</td>\n<td style=\"text-align:left\">不用扫描表或索引</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">system</td>\n<td style=\"text-align:left\">表中只有一行记录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">const</td>\n<td style=\"text-align:left\">通过索引一次就能找到，只匹配一行记录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">eq_ref</td>\n<td style=\"text-align:left\">通过唯一索引查询，每一个索引键只有一行记录与之匹配，常见于主键或唯一索引扫描</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ref</td>\n<td style=\"text-align:left\">通过非唯一性索引查询，返回每一个索引键对应的多行记录，常见于带索引的列使用=操作符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">range</td>\n<td style=\"text-align:left\">通过索引查询指定范围的行，常见于带索引的列使用between、&gt;和&lt;操作符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">index</td>\n<td style=\"text-align:left\">只遍历索引树</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ALL</td>\n<td style=\"text-align:left\">全表扫描</td>\n</tr>\n</tbody>\n</table>\n<p><strong>possible_keys:</strong> 指出mysql使用哪个索引在该表找到行记录。如果该值为NULL，说明没有使用索引，可以建立索引提高性能<br><strong>key:</strong> 指出mysql实际使用的索引。如果为NULL，则没有使用索引查询<br><strong>key_len:</strong> 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。显示的是索引字段的最大长度，并非实际使用长度<br><strong>ref:</strong> 显示该表的索引字段关联了哪张表的哪个字段<br><strong>rows:</strong> 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好<br><strong>filtered:</strong> 返回结果的行数占读取行数的百分比，值越大越好<br><strong>extra:</strong> 包含不适合在其他列中显示但十分重要的额外信息。常见的值如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Using filesort</td>\n<td style=\"text-align:left\">mysql对数据使用一个外部索引进行排序，而不是根据表内的索引顺序进行读取，若出现该值则SQL需要优化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Using temporary</td>\n<td style=\"text-align:left\">mysql使用了临时表保存中间结果，常见于order by和group by，若出现该值则SQL需要优化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Using index</td>\n<td style=\"text-align:left\">select操作使用了覆盖索引，避免了数据回行操作，效率不错</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Using where</td>\n<td style=\"text-align:left\">select操作使用了where语句限制哪一行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Using join buffer(Block Nested Loop)</td>\n<td style=\"text-align:left\">使用了连接缓存，括号里表示使用了哪种连接算法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Distinct</td>\n<td style=\"text-align:left\">发现第一个匹配后，停止为当前的行组合搜索更多的行</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"二、总结\"><a href=\"#二、总结\" class=\"headerlink\" title=\"二、总结\"></a>二、总结</h1><p>以上就是mysql数据库SQL查询的基础知识，具体SQL如何优化还需要自己多操作。掌握了SQL语句的详细执行计划后，我们就能够根据实际业务来调整SQL语句，使之性能有所提高。</p>\n","slug":"1-002","updated":"2020-07-18T13:49:15.303Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2019/06/30/1-002/","excerpt":"","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.elfli.cn/categories/后端/"}],"tags":[{"name":"技术随笔","slug":"技术随笔","permalink":"https://blog.elfli.cn/tags/技术随笔/"},{"name":"mysql","slug":"mysql","permalink":"https://blog.elfli.cn/tags/mysql/"}]},{"title":"如何在MAC系统下从无到有搭建起自己的个人博客（GITHUB+HEXO）","date":"2019-04-01T16:00:00.000Z","path":"2019/04/02/1-001/","text":"声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！ 此篇只针对于Mac系统上个人博客的搭建，有官方文档的都不再进行详细阐述；主要目的是为了自己能够随时回顾，所以仅供大家参考！ 一、环境准备（Mac、NVM、Homebrew、nodeJS、Git、Hexo）1、首先当然是要有一台装有Mac系统的电脑了，本人Mac系统version为macOS 10.14.4.2、安装nvm(Node Version Manager)，详细安装步骤参考官方文档，在这里不进行详细阐述，下面是我使用的安装命令：1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 3、使用nvm安装nodeJS，详细安装步骤参考官方文档，下面是我使用的安装命令：1nvm install node # 默认安装最新版本的node 4、我们需要用到一个Mac系统的套件安装神器Homebrew，以方便下面git等套件的管理，详细参考官方文档，下面是我使用的安装命令：1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 5、接下来我们可以开始安装git了，很简单，使用以下命令安装：1brew install git 6、上面这么多的准备工作，终于步入了正题；下面开始安装Hexo，同样我们可以参考官方文档，下面是我使用的安装命令：1npm install -g hexo-cli 7、在初始化Hexo之前，还需要指定一个安装目录比如Blog，然后执行安装命令：12hexo initnpm install 此时在执行npm install命令时遇到了第一个坑，系统报如下问题： found 3 vulnerabilities (2 low, 1 moderate)run npm audit fix to fix them, or npm audit for details 虽然不影响后续的运行，但是对于有点代码强迫症的我来说看着真不舒服。按照给出的建议执行sudo npm audit fix命令后，漏洞并没有修复，这就导致了npm install命令总会提示这段信息： 解决方法就是，执行一下npm audit命令可以找到含有漏洞的包，直接定位有问题的模块并修改依赖包的版本即可解决： 8、这里列出几个常用的Hexo命令以及简写方式： hexo n == hexo new 新建postshexo g == hexo generate 生成可部署代码hexo clean 清空生成的可部署代码hexo s == hexo server 启动本地web服务hexo d == hexo deploy 代码部署到指定到repository 二、安装主题1、首先从Hexo主题官方网址选择一个中意的主题，搬运请遵守所选主题的LICENSE，不要随意搬运啊！2、选好主题后，我们就可以直接使用git命令clone到自己的博客目录下了；如果想要在搬运来的主题基础上自定义，可以把中意的主题直接fork到自己的GitHub下，然后clone到博客目录下，当然这样就无法直接获取到主题原作者的更新内容了（前提是原作者还在维护这个主题^_^）；至于主题的更新等请参照git的使用方法，例如我搬运的主题：12cd ~Myself/Bloggit clone git@github.com:litten/hexo-theme-yilia.git themes/yilia 3、然后修改Blog目录下的_config.yml文件中的theme属性为yilia，主题通常有也有自己的配置，直接按照主题说明粘贴即可，最终效果如图： 三、部署到GitHub（如何使用GitHub请自行百度）1、首先在自己的GitHub中新建一个空的repository，名称必须为xxx.github.io(xxx填写自己的GitHub账号)；新建过后进入Settings选项卡，向下拉最终看到如下图所示即可： 2、Hexo想要通过git部署到GitHub上，需要安装一个git组件：1npm install hexo-deployer-git --save 3、安装完成以后，打开Blog目录下的_config.yml文件，添加或者编辑以下内容：1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master 4、接下来就可以使用Hexo命令进行部署了，命令如下：12hexo g # 生成可部署代码hexo d # 代码部署到指定到repository 四、添加评论功能1、网上有很多可用的评论功能，但是GitHub搭建的博客当然使用自家的比较好，这里选择Gitment支持并存储博客的评论；首先注册一个OAuth Application，如何注册参考下图： 注册成功后会得到如下图所示的Client ID和Client Secret，后面配置时需要用到这两个值： 2、然后需要在GitHub中新建一个空的repository，名称随意，用来存储评论生成的issues；3、接下来我们就可以开始修改主题的_config.yml文件，每一个主题的属性命名各有不同，比如yilia主题的如下：12345gitment_owner: &apos;xxx&apos; #你的 GitHub IDgitment_repo: &apos;hexo-blog-comment&apos; #存储评论的 repogitment_oauth: client_id: &apos;9c6d1dd38b44a3f1cccd&apos; #client ID client_secret: &apos;186f09d7289112612478132849df2b822d509cb0&apos; #client secret 其实对应的代码部分如下所示：123456789101112131415161718&lt;div id=\"gitment-ctn\"&gt;&lt;/div&gt;&lt;!--英文版--&gt;&lt;!--&lt;link rel=\"stylesheet\" href=\"//imsun.github.io/gitment/style/default.css\"&gt;--&gt;&lt;!--&lt;script src=\"//imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt;--&gt;&lt;link rel=\"stylesheet\" href=\"https://billts.site/extra_css/gitment.css\"&gt;&lt;script src=\"https://billts.site/js/gitment.js\"&gt;&lt;/script&gt;&lt;script&gt; var gitment = new Gitment(&#123; id: \"&lt;%= page.date %&gt;\", owner: '&lt;%= theme.gitment_owner %&gt;', repo: '&lt;%= theme.gitment_repo %&gt;', oauth: &#123; client_id: '&lt;%= theme.gitment_oauth.client_id %&gt;', client_secret: '&lt;%= theme.gitment_oauth.client_secret %&gt;', &#125;, &#125;) gitment.render('gitment-ctn')&lt;/script&gt; 4、到此为止基本的Gitment配置就完成了，不过唯一不方便的地方就是每一篇博客都需要自己登陆后初始化评论，如下图所示，登陆自己的GitHub账号后初始化即可： 五、添加百度统计1、为了能够监控到博客的访问量等信息，我们可以给博客添加一些分析统计功能，当然相应的工具也很多了，不过目前主要是谷歌和百度使用的比较多，而国内自然也推荐使用百度统计啦！添加百度统计首先需要注册一个百度统计的账号，百度账号不能使用。登录成功后进入管理模块，添加一个自己的网站，如下图所示： 2、添加成功后会获取到一段统计代码，把这段代码添加在自己博客的html页面上即可，其中最主要的是hm.src后面的部分： 六、总结经过以上的努力奋战后，终于可以坐下来享受书写博客的乐趣了！当然这也是我职业生涯中的第一篇博客，我尽可能的想做到尽善尽美。所有的知识几乎都是搬来搬去，只有转化为自己的知识才是真正的收获，这就让我产生了学习一下前端的想法。作为一个纯后端的Java工程师，对现在的前端知识只是一知半解，已经无法自定义出来自己喜欢的主题以及界面了，只好借前端大牛的主题先拿来用用，后面再进行自定义了。","raw":"---\ntitle: 如何在MAC系统下从无到有搭建起自己的个人博客（GITHUB+HEXO）\n\ndate: 2019-04-02\n\ntoc: true\n\ncategories: \n- 前端\n\ntags: \n- JS\n- 技术随笔\n---\n***声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！***\n\n---\n\n**此篇只针对于Mac系统上个人博客的搭建，有官方文档的都不再进行详细阐述；主要目的是为了自己能够随时回顾，所以仅供大家参考！**\n\n## 一、环境准备（Mac、NVM、Homebrew、nodeJS、Git、Hexo）\n1、首先当然是要有一台装有Mac系统的电脑了，本人Mac系统version为macOS 10.14.4.\n2、安装nvm(Node Version Manager)，详细安装步骤参考[官方文档](https://github.com/creationix/nvm/blob/master/README.md)，在这里不进行详细阐述，下面是我使用的安装命令：\n```bash\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash\n```\n3、使用nvm安装nodeJS，详细安装步骤参考[官方文档](https://github.com/creationix/nvm/blob/master/README.md)，下面是我使用的安装命令：\n```bash\nnvm install node # 默认安装最新版本的node\n```\n4、我们需要用到一个Mac系统的套件安装神器Homebrew，以方便下面git等套件的管理，详细参考[官方文档](https://brew.sh)，下面是我使用的安装命令：\n```bash\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n5、接下来我们可以开始安装git了，很简单，使用以下命令安装：\n```bash\nbrew install git\n```\n6、上面这么多的准备工作，终于步入了正题；下面开始安装Hexo，同样我们可以参考[官方文档](https://hexo.io/docs/)，下面是我使用的安装命令：\n```bash\nnpm install -g hexo-cli\n```\n7、在初始化Hexo之前，还需要指定一个安装目录比如Blog，然后执行安装命令：\n```bash\nhexo init\nnpm install\n```\n\n---\n\n***此时在执行npm install命令时遇到了第一个坑，系统报如下问题：***\n\n> found 3 vulnerabilities (2 low, 1 moderate)\n> run `npm audit fix` to fix them, or `npm audit` for details\n\n虽然不影响后续的运行，但是对于有点代码强迫症的我来说看着真不舒服。按照给出的建议执行sudo npm audit fix命令后，漏洞并没有修复，这就导致了npm install命令总会提示这段信息：\n<div align=center><img src=\"/assets/img/blog/1_001_20190402/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n解决方法就是，执行一下npm audit命令可以找到含有漏洞的包，直接定位有问题的模块并修改依赖包的版本即可解决：\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n8、这里列出几个常用的Hexo命令以及简写方式：\n\n> hexo n == hexo new 新建posts\n> hexo g == hexo generate 生成可部署代码\n> hexo clean 清空生成的可部署代码\n> hexo s == hexo server 启动本地web服务\n> hexo d == hexo deploy 代码部署到指定到repository\n\n\n---\n\n## 二、安装主题\n1、首先从[Hexo主题官方网址](https://hexo.io/themes/)选择一个中意的主题，搬运请遵守所选主题的LICENSE，不要随意搬运啊！\n2、选好主题后，我们就可以直接使用git命令clone到自己的博客目录下了；如果想要在搬运来的主题基础上自定义，可以把中意的主题直接fork到自己的GitHub下，然后clone到博客目录下，当然这样就无法直接获取到主题原作者的更新内容了（前提是原作者还在维护这个主题^_^）；至于主题的更新等请参照git的使用方法，例如我搬运的主题：\n```bash\ncd ~Myself/Blog\ngit clone git@github.com:litten/hexo-theme-yilia.git themes/yilia\n```\n3、然后修改Blog目录下的_config.yml文件中的theme属性为yilia，主题通常有也有自己的配置，直接按照主题说明粘贴即可，最终效果如图：\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n---\n\n## 三、部署到GitHub（如何使用GitHub请自行百度）\n1、首先在自己的GitHub中新建一个空的repository，名称必须为xxx.github.io(xxx填写自己的GitHub账号)；新建过后进入Settings选项卡，向下拉最终看到如下图所示即可：\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>\n\n2、Hexo想要通过git部署到GitHub上，需要安装一个git组件：\n```bash\nnpm install hexo-deployer-git --save\n```\n3、安装完成以后，打开Blog目录下的_config.yml文件，添加或者编辑以下内容：\n```\ndeploy:\n  type: git\n  repo: git@github.com:xxx/xxx.github.io.git\n  branch: master\n```\n4、接下来就可以使用Hexo命令进行部署了，命令如下：\n```bash\nhexo g # 生成可部署代码\nhexo d # 代码部署到指定到repository\n```\n\n---\n\n## 四、添加评论功能\n1、网上有很多可用的评论功能，但是GitHub搭建的博客当然使用自家的比较好，这里选择Gitment支持并存储博客的评论；\n首先注册一个[OAuth Application](https://github.com/settings/applications/new)，如何注册参考下图：\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/05.jpg\" alt=\"图5\" width=\"80%\" height=\"80%\"></div>\n\n注册成功后会得到如下图所示的Client ID和Client Secret，后面配置时需要用到这两个值：\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/06.jpg\" alt=\"图6\" width=\"80%\" height=\"80%\"></div>\n\n2、然后需要在GitHub中新建一个空的repository，名称随意，用来存储评论生成的issues；\n3、接下来我们就可以开始修改主题的_config.yml文件，每一个主题的属性命名各有不同，比如yilia主题的如下：\n```\ngitment_owner: 'xxx'            #你的 GitHub ID\ngitment_repo: 'hexo-blog-comment'         #存储评论的 repo\ngitment_oauth:\n  client_id: '9c6d1dd38b44a3f1cccd'                             #client ID\n  client_secret: '186f09d7289112612478132849df2b822d509cb0'     #client secret\n```\n其实对应的代码部分如下所示：\n```html\n<div id=\"gitment-ctn\"></div>\n<!--英文版-->\n<!--<link rel=\"stylesheet\" href=\"//imsun.github.io/gitment/style/default.css\">-->\n<!--<script src=\"//imsun.github.io/gitment/dist/gitment.browser.js\"></script>-->\n<link rel=\"stylesheet\" href=\"https://billts.site/extra_css/gitment.css\">\n<script src=\"https://billts.site/js/gitment.js\"></script>\n<script>\n  var gitment = new Gitment({\n    id: \"<%= page.date %>\",\n    owner: '<%= theme.gitment_owner %>',\n    repo: '<%= theme.gitment_repo %>',\n    oauth: {\n      client_id: '<%= theme.gitment_oauth.client_id %>',\n      client_secret: '<%= theme.gitment_oauth.client_secret %>',\n    },\n  })\n  gitment.render('gitment-ctn')\n</script>\n```\n4、到此为止基本的Gitment配置就完成了，不过唯一不方便的地方就是每一篇博客都需要自己登陆后初始化评论，如下图所示，登陆自己的GitHub账号后初始化即可：\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/07.jpg\" alt=\"图7\" width=\"80%\" height=\"80%\"></div>\n\n---\n\n## 五、添加百度统计\n1、为了能够监控到博客的访问量等信息，我们可以给博客添加一些分析统计功能，当然相应的工具也很多了，不过目前主要是谷歌和百度使用的比较多，而国内自然也推荐使用百度统计啦！\n添加[百度统计](https://tongji.baidu.com/web/welcome/login)首先需要注册一个百度统计的账号，百度账号不能使用。登录成功后进入管理模块，添加一个自己的网站，如下图所示：\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/08.jpg\" alt=\"图8\" width=\"80%\" height=\"80%\"></div>\n\n2、添加成功后会获取到一段统计代码，把这段代码添加在自己博客的html页面上即可，其中最主要的是hm.src后面的部分：\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/09.jpg\" alt=\"图9\" width=\"80%\" height=\"80%\"></div>\n\n---\n\n## 六、总结\n经过以上的努力奋战后，终于可以坐下来享受书写博客的乐趣了！当然这也是我职业生涯中的第一篇博客，我尽可能的想做到尽善尽美。所有的知识几乎都是搬来搬去，只有转化为自己的知识才是真正的收获，这就让我产生了学习一下前端的想法。作为一个纯后端的Java工程师，对现在的前端知识只是一知半解，已经无法自定义出来自己喜欢的主题以及界面了，只好借前端大牛的主题先拿来用用，后面再进行自定义了。","content":"<p><strong><em>声明：文章含有搬运部分，若有侵权请告知，转载请注明出处！</em></strong></p>\n<hr>\n<p><strong>此篇只针对于Mac系统上个人博客的搭建，有官方文档的都不再进行详细阐述；主要目的是为了自己能够随时回顾，所以仅供大家参考！</strong></p>\n<h2 id=\"一、环境准备（Mac、NVM、Homebrew、nodeJS、Git、Hexo）\"><a href=\"#一、环境准备（Mac、NVM、Homebrew、nodeJS、Git、Hexo）\" class=\"headerlink\" title=\"一、环境准备（Mac、NVM、Homebrew、nodeJS、Git、Hexo）\"></a>一、环境准备（Mac、NVM、Homebrew、nodeJS、Git、Hexo）</h2><p>1、首先当然是要有一台装有Mac系统的电脑了，本人Mac系统version为macOS 10.14.4.<br>2、安装nvm(Node Version Manager)，详细安装步骤参考<a href=\"https://github.com/creationix/nvm/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">官方文档</a>，在这里不进行详细阐述，下面是我使用的安装命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure></p>\n<p>3、使用nvm安装nodeJS，详细安装步骤参考<a href=\"https://github.com/creationix/nvm/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">官方文档</a>，下面是我使用的安装命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install node <span class=\"comment\"># 默认安装最新版本的node</span></span><br></pre></td></tr></table></figure></p>\n<p>4、我们需要用到一个Mac系统的套件安装神器Homebrew，以方便下面git等套件的管理，详细参考<a href=\"https://brew.sh\" target=\"_blank\" rel=\"noopener\">官方文档</a>，下面是我使用的安装命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e <span class=\"string\">\"<span class=\"variable\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<p>5、接下来我们可以开始安装git了，很简单，使用以下命令安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install git</span><br></pre></td></tr></table></figure></p>\n<p>6、上面这么多的准备工作，终于步入了正题；下面开始安装Hexo，同样我们可以参考<a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">官方文档</a>，下面是我使用的安装命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>\n<p>7、在初始化Hexo之前，还需要指定一个安装目录比如Blog，然后执行安装命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong><em>此时在执行npm install命令时遇到了第一个坑，系统报如下问题：</em></strong></p>\n<blockquote>\n<p>found 3 vulnerabilities (2 low, 1 moderate)<br>run <code>npm audit fix</code> to fix them, or <code>npm audit</code> for details</p>\n</blockquote>\n<p>虽然不影响后续的运行，但是对于有点代码强迫症的我来说看着真不舒服。按照给出的建议执行sudo npm audit fix命令后，漏洞并没有修复，这就导致了npm install命令总会提示这段信息：</p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/01.jpg\" alt=\"图1\" width=\"80%\" height=\"80%\"></div>\n\n<p>解决方法就是，执行一下npm audit命令可以找到含有漏洞的包，直接定位有问题的模块并修改依赖包的版本即可解决：</p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/02.jpg\" alt=\"图2\" width=\"80%\" height=\"80%\"></div>\n\n<p>8、这里列出几个常用的Hexo命令以及简写方式：</p>\n<blockquote>\n<p>hexo n == hexo new 新建posts<br>hexo g == hexo generate 生成可部署代码<br>hexo clean 清空生成的可部署代码<br>hexo s == hexo server 启动本地web服务<br>hexo d == hexo deploy 代码部署到指定到repository</p>\n</blockquote>\n<hr>\n<h2 id=\"二、安装主题\"><a href=\"#二、安装主题\" class=\"headerlink\" title=\"二、安装主题\"></a>二、安装主题</h2><p>1、首先从<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题官方网址</a>选择一个中意的主题，搬运请遵守所选主题的LICENSE，不要随意搬运啊！<br>2、选好主题后，我们就可以直接使用git命令clone到自己的博客目录下了；如果想要在搬运来的主题基础上自定义，可以把中意的主题直接fork到自己的GitHub下，然后clone到博客目录下，当然这样就无法直接获取到主题原作者的更新内容了（前提是原作者还在维护这个主题^_^）；至于主题的更新等请参照git的使用方法，例如我搬运的主题：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~Myself/Blog</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure></p>\n<p>3、然后修改Blog目录下的_config.yml文件中的theme属性为yilia，主题通常有也有自己的配置，直接按照主题说明粘贴即可，最终效果如图：</p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/03.jpg\" alt=\"图3\" width=\"80%\" height=\"80%\"></div>\n\n<hr>\n<h2 id=\"三、部署到GitHub（如何使用GitHub请自行百度）\"><a href=\"#三、部署到GitHub（如何使用GitHub请自行百度）\" class=\"headerlink\" title=\"三、部署到GitHub（如何使用GitHub请自行百度）\"></a>三、部署到GitHub（如何使用GitHub请自行百度）</h2><p>1、首先在自己的GitHub中新建一个空的repository，名称必须为xxx.github.io(xxx填写自己的GitHub账号)；新建过后进入Settings选项卡，向下拉最终看到如下图所示即可：</p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/04.jpg\" alt=\"图4\" width=\"80%\" height=\"80%\"></div>\n\n<p>2、Hexo想要通过git部署到GitHub上，需要安装一个git组件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>3、安装完成以后，打开Blog目录下的_config.yml文件，添加或者编辑以下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:xxx/xxx.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>4、接下来就可以使用Hexo命令进行部署了，命令如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g <span class=\"comment\"># 生成可部署代码</span></span><br><span class=\"line\">hexo d <span class=\"comment\"># 代码部署到指定到repository</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"四、添加评论功能\"><a href=\"#四、添加评论功能\" class=\"headerlink\" title=\"四、添加评论功能\"></a>四、添加评论功能</h2><p>1、网上有很多可用的评论功能，但是GitHub搭建的博客当然使用自家的比较好，这里选择Gitment支持并存储博客的评论；<br>首先注册一个<a href=\"https://github.com/settings/applications/new\" target=\"_blank\" rel=\"noopener\">OAuth Application</a>，如何注册参考下图：</p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/05.jpg\" alt=\"图5\" width=\"80%\" height=\"80%\"></div>\n\n<p>注册成功后会得到如下图所示的Client ID和Client Secret，后面配置时需要用到这两个值：</p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/06.jpg\" alt=\"图6\" width=\"80%\" height=\"80%\"></div>\n\n<p>2、然后需要在GitHub中新建一个空的repository，名称随意，用来存储评论生成的issues；<br>3、接下来我们就可以开始修改主题的_config.yml文件，每一个主题的属性命名各有不同，比如yilia主题的如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitment_owner: &apos;xxx&apos;            #你的 GitHub ID</span><br><span class=\"line\">gitment_repo: &apos;hexo-blog-comment&apos;         #存储评论的 repo</span><br><span class=\"line\">gitment_oauth:</span><br><span class=\"line\">  client_id: &apos;9c6d1dd38b44a3f1cccd&apos;                             #client ID</span><br><span class=\"line\">  client_secret: &apos;186f09d7289112612478132849df2b822d509cb0&apos;     #client secret</span><br></pre></td></tr></table></figure></p>\n<p>其实对应的代码部分如下所示：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"gitment-ctn\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--英文版--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--&lt;link rel=\"stylesheet\" href=\"//imsun.github.io/gitment/style/default.css\"&gt;--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--&lt;script src=\"//imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt;--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://billts.site/extra_css/gitment.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://billts.site/js/gitment.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  var gitment = new Gitment(&#123;</span></span><br><span class=\"line\"><span class=\"xml\">    id: \"<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">page.date</span> %&gt;</span>\",</span></span><br><span class=\"line\"><span class=\"xml\">    owner: '<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">theme.gitment_owner</span> %&gt;</span>',</span></span><br><span class=\"line\"><span class=\"xml\">    repo: '<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">theme.gitment_repo</span> %&gt;</span>',</span></span><br><span class=\"line\"><span class=\"undefined\">    oauth: &#123;</span></span><br><span class=\"line\"><span class=\"xml\">      client_id: '<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">theme.gitment_oauth.client_id</span> %&gt;</span>',</span></span><br><span class=\"line\"><span class=\"xml\">      client_secret: '<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">theme.gitment_oauth.client_secret</span> %&gt;</span>',</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">  gitment.render('gitment-ctn')</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>4、到此为止基本的Gitment配置就完成了，不过唯一不方便的地方就是每一篇博客都需要自己登陆后初始化评论，如下图所示，登陆自己的GitHub账号后初始化即可：</p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/07.jpg\" alt=\"图7\" width=\"80%\" height=\"80%\"></div>\n\n<hr>\n<h2 id=\"五、添加百度统计\"><a href=\"#五、添加百度统计\" class=\"headerlink\" title=\"五、添加百度统计\"></a>五、添加百度统计</h2><p>1、为了能够监控到博客的访问量等信息，我们可以给博客添加一些分析统计功能，当然相应的工具也很多了，不过目前主要是谷歌和百度使用的比较多，而国内自然也推荐使用百度统计啦！<br>添加<a href=\"https://tongji.baidu.com/web/welcome/login\" target=\"_blank\" rel=\"noopener\">百度统计</a>首先需要注册一个百度统计的账号，百度账号不能使用。登录成功后进入管理模块，添加一个自己的网站，如下图所示：</p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/08.jpg\" alt=\"图8\" width=\"80%\" height=\"80%\"></div>\n\n<p>2、添加成功后会获取到一段统计代码，把这段代码添加在自己博客的html页面上即可，其中最主要的是hm.src后面的部分：</p>\n<div align=\"center\"><img src=\"/assets/img/blog/1_001_20190402/09.jpg\" alt=\"图9\" width=\"80%\" height=\"80%\"></div>\n\n<hr>\n<h2 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h2><p>经过以上的努力奋战后，终于可以坐下来享受书写博客的乐趣了！当然这也是我职业生涯中的第一篇博客，我尽可能的想做到尽善尽美。所有的知识几乎都是搬来搬去，只有转化为自己的知识才是真正的收获，这就让我产生了学习一下前端的想法。作为一个纯后端的Java工程师，对现在的前端知识只是一知半解，已经无法自定义出来自己喜欢的主题以及界面了，只好借前端大牛的主题先拿来用用，后面再进行自定义了。</p>\n","slug":"1-001","updated":"2020-07-18T13:49:15.316Z","comments":true,"link":"","permalink":"https://blog.elfli.cn/2019/04/02/1-001/","excerpt":"","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.elfli.cn/categories/前端/"}],"tags":[{"name":"技术随笔","slug":"技术随笔","permalink":"https://blog.elfli.cn/tags/技术随笔/"},{"name":"JS","slug":"JS","permalink":"https://blog.elfli.cn/tags/JS/"}]}]